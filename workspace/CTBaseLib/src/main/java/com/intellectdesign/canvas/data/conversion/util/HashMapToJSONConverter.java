/** * Copyright 2014. Intellect Design Arena Limited. All rights reserved.  *  * These materials are confidential and proprietary to Intellect Design Arena  * Limited and no part of these materials should be reproduced, published, transmitted * or distributed in any form or by any means, electronic, mechanical, photocopying,  * recording or otherwise, or stored in any information storage or retrieval system  * of any nature nor should the materials be disclosed to third parties or used in any  * other manner for which this is not authorized, without the prior express written  * authorization of Intellect Design Arena Limited. *  */package com.intellectdesign.canvas.data.conversion.util;import java.math.BigDecimal;import java.text.SimpleDateFormat;import java.util.Arrays;import java.util.Date;import java.util.Iterator;import java.util.List;import java.util.Map;import com.intellectdesign.canvas.common.IBaseDefinition;import com.intellectdesign.canvas.logger.Logger;import com.intellectdesign.canvas.utils.StringUtils;/** * This is an utility class which converts an hashmap to a JSON format A JSON string format is as follows *  * { "firstName": "John", "lastName": "Smith", "address": { "streetAddress": "21 2nd Street", "city": "New York", * "state": "NY", "postalCode": 10021 }, "phoneNumbers": [ "212 732-1234", "646 123-4567" ] } where every key in the map * is placed with quotes and every value of that key is place within quotes the key and value are separated by a : each * key-value pair of the map is seprated by a comma if the value is an array, the array itself is enclosed with [] * (square brackets) and each element in the array is separated by a comma This class does the above following on some * basic assumptions/rules *  * the keys in the input hashmap are directly converted to string using the .toString api if the key itself is null, it * generates a null object (i.e the string null without the quotes) the values can be either plain object or array or a * List if it is plain object, it simply calls the toString() on the object if the plain object is null, it simply * generate a null object *  * if the value is List or an object array, a JSON array string is generated as per the above format *  * it supports any level of nested hashmap/list/arrays *  * if any of the hashmap/list/array is null or empty, an empty json text for that value is generated *  * @version 1.0 */public class HashMapToJSONConverter{	private HashMapToJSONConverter(List dateList)	{		/**		 * This method for HashMapTO JSONConverter		 * 		 * @parm ListdateList		 */		this.dateList = dateList;	}	/**	 * This method for HashMapTO JSONConverter	 * 	 * @parm ListdateList,List maskList	 */	private HashMapToJSONConverter(List dateList, List maskList)	{		this.dateList = dateList;	}	/**	 * This method for HashMapTO JSONConverter	 * 	 * 	 */	public HashMapToJSONConverter()	{	}	/**	 * Converts the given map to a jsonstring Refer this class's documentation to know more details	 * 	 * @param hashMap	 * @return string in JSON format	 */	public static String convertHashMapToJSONFormat(Map hashMap)	{		String jsonString = new HashMapToJSONConverter().generateJSONMap(hashMap);		return jsonString;	}	/**	 * Converts the given map to a jsonstring Refer this class's documentation to know more details	 * 	 * @param hashMap	 * @param isHtmlEncodeNeeded	 * @return string in JSON format	 */	public static String convertHashMapToJSONFormat(Map hashMap, boolean isHtmlEncodeNeeded)	{		isHtmlEncodeNeed = isHtmlEncodeNeeded;		String jsonString = new HashMapToJSONConverter().generateJSONMap(hashMap);		isHtmlEncodeNeed = true;		return jsonString;	}	/**	 * Converts the given map to a jsonstring Refer this class's documentation to know more details	 * 	 * @param hashMap	 * @param datefieldList - List of date filed id's whos value should be Ext date object not string	 * @return string in JSON format	 */	public static String convertHashMapToJSONFormat(Map hashMap, List datefieldList)	{		String jsonString = new HashMapToJSONConverter(datefieldList).generateJSONMap(hashMap);		return jsonString;	}	/**	 * Converts the given map to a jsonstring Refer this class's documentation to know more details	 * 	 * @param hashMap	 * @param datefieldList - List of date filed id's whos value should be Ext date object not string	 * @return string in JSON format	 */	public static String convertHashMapToJSONFormat(Map hashMap, List datefieldList, List maskFieldList)	{		String jsonString = new HashMapToJSONConverter(datefieldList, maskFieldList).generateJSONMap(hashMap);		return jsonString;	}	public static String convertListToJSONFormat(List data)	{		String jsonString = new HashMapToJSONConverter().generateJSONValue(data, "RESULT");		return jsonString;	}	/**	 * Converts the given map to a jsonstring Refer this class's documentation to know more details this is a refactored	 * method for supporting nested hashmap	 * 	 * @param hashmap	 * @return string in JSON format	 */	private String generateJSONMap(Map hashmap)	{		StringBuffer jsonString = new StringBuffer();		jsonString.append(HASHMAP_PREFIX);		// for each key value pair in the hashmap		// generate the key		// append the key-value separator		// generate the value		// append the hashmap element separator		if (hashmap != null && !hashmap.isEmpty())		{			Iterator keyIterator = hashmap.keySet().iterator();			Object aKey;			Object aValue;			while (true)			{				aKey = keyIterator.next();				aValue = hashmap.get(aKey);				// The masking logic should come here				// If aKey is a data element that needs masking then begin masking routine				String jsonKey = this.generateJSONKey(aKey);				String jsonValue = this.generateJSONValue(aValue, aKey);				jsonString.append(jsonKey);				jsonString.append(HASHMAP_KEY_VALUE_SEPARATOR);				jsonString.append(jsonValue);				// append the element seprator only if there is a next element				if (keyIterator.hasNext())					jsonString.append(HASHMAP_ELEMENT_SEPARATOR);				else					break;			}		}		jsonString.append(HASHMAP_SUFFIX);		return jsonString.toString();	}	/**	 * Generates JSON string for a value This method is the one which checks the type of the object and delegates to	 * appropriate generator the supported types are List, Object[], Map if aValue's type does not match any of the	 * above type, it assumes its a plain value and gets the JSON string a plain value	 * 	 * @param aValue	 * @return string in JSON format	 */	private String generateJSONValue(Object aValue, Object aKey)	{		// if value is a hashmap, handle hashmap		// if value is a collection, handle collection		// if value is an array, handle array		// else handle plain value		if (aValue instanceof Map)			return this.generateJSONMap((Map) aValue);		else if (aValue instanceof List)			return this.generateJSONCollection((List) aValue, aKey);		else if (aValue instanceof Object[])			return this.generateJSONCollection((Object[]) aValue, aKey);		/**		 * Added another check for objects that build their own JSON representation.		 * */		else if (aValue instanceof IBaseDefinition)			return ((IBaseDefinition) aValue).toJSONString();		else			return this.generateJSONPlainValue(aValue, aKey);	}	/**	 * Method to generate JSON string for a List of objects	 * 	 * @param aCollection	 * @return string in JSON format	 */	private String generateJSONCollection(List aCollection, Object aKey)	{		Iterator aIterator = null;		if (aCollection != null)			aIterator = aCollection.iterator();		return this.generateJSONCollection(aIterator, aKey);	}	/**	 * Method to generate JSON string for an array objects	 * 	 * @param aCollection	 * @return string in JSON format	 */	private String generateJSONCollection(Object[] aCollection, Object aKey)	{		return this.generateJSONCollection(getArrayIterator(aCollection), aKey);	}	/**	 * Method to generate JSON string for a object iterator	 * 	 * @param aCollectionIterator	 * @return string in JSON format	 */	private String generateJSONCollection(Iterator aCollectionIterator, Object aKey)	{		StringBuffer jsonString = new StringBuffer();		jsonString.append(COLLECTION_PREFIX);		if (aCollectionIterator != null && aCollectionIterator.hasNext())		{			// for each element in the collection call handle one value			while (true)			{				jsonString.append(this.generateJSONValue(aCollectionIterator.next(), aKey));				if (aCollectionIterator.hasNext())					jsonString.append(COLLECTION_ELEMENT_SEPARATOR);				else					break;			}		}		jsonString.append(COLLECTION_SUFFIX);		return jsonString.toString();	}	/**	 * Generates JSON string for a plain value Refer the class's documentation for more details about the JSON string	 * generation rules	 * 	 * @param aValue	 * @return string in JSON format	 */	private String generateJSONPlainValue(Object aValue, Object aKey)	{		StringBuffer jsonString = new StringBuffer();		if (aValue != null)		{			if (this.dateList != null)			{				if (this.dateList.contains(aKey.toString()))				{					String dateJsObj = writeDateObject(aValue.toString());					if (!dateJsObj.equals("NaD"))					{ // NaD --> Not a Date						jsonString.append(dateJsObj);						return jsonString.toString();					}				}			}			if (aValue instanceof Date)			{				jsonString.append(VALUE_PREFIX);				jsonString.append(DEFAULT_DATE_FORMATTER.format(aValue));				jsonString.append(VALUE_SUFFIX);			} else if (aValue instanceof Float)			{				jsonString.append(VALUE_PREFIX);				// jsonString.append(replaceUicodesForSpecialChars((new BigDecimal((((Float)				// aValue).floatValue()))).toPlainString()));				jsonString.append(replaceUicodesForSpecialChars((new BigDecimal(Float.toString((Float) aValue)))						.toPlainString()));				jsonString.append(VALUE_SUFFIX);			} else if (aValue instanceof BigDecimal)			{				jsonString.append(VALUE_PREFIX);				jsonString.append(replaceUicodesForSpecialChars(((BigDecimal) aValue).toPlainString()));				jsonString.append(VALUE_SUFFIX);			} else			{				jsonString.append(VALUE_PREFIX);				jsonString.append(replaceUicodesForSpecialChars(aValue.toString()));				jsonString.append(VALUE_SUFFIX);			}		} else			jsonString.append(JS_NULL_OBJECT);		return jsonString.toString();	}	/**	 * Replace the following chars Char == Unicode Value. \"  	== 	\u0022 \b == \u0008 \f == \n == \r == \t == with	 * Unicode	 * 	 * @param aValue	 * @return Replaced value	 */	private String replaceUicodesForSpecialChars(String aValue)	{		// removed previous code to bring pure HTML content directly from server to client.		String value;		if (isHtmlEncodeNeed)		{			aValue = StringUtils.htmlEncode(aValue, " ");		}		value = aValue.replaceAll("\"", "\\\\u0022").replaceAll("\b", "\\\\u0008").replaceAll("\f", "\\\\u000C")				.replaceAll("\n", "\\\\u000A").replaceAll("\r", "\\\\u000D").replaceAll("\t", "\\\\u0009");		return value;	}	/**	 * If the HashMaps value passes the primary requisite for being a Date this method will be called with the array of	 * date parts.	 * 	 * @param dateFields Array of 3 elements ---> [DD,MM,YYYY]	 **/	public String writeDateObject(String serverDateStamp)	{		String[] dateFields = serverDateStamp.split("/");		StringBuffer dateJSON = new StringBuffer();		try		{			dateJSON.append("function(){var xdate= new Date();");			dateJSON.append("xdate.setFullYear(");			dateJSON.append(Integer.parseInt(dateFields[2]));			dateJSON.append(",");			dateJSON.append((Integer.parseInt(dateFields[1]) - 1));			dateJSON.append(",");			dateJSON.append(Integer.parseInt(dateFields[0]));			dateJSON.append(");");			dateJSON.append("return xdate;}()");			logger.ctdebug("CTBAS00007", dateJSON.toString());			return dateJSON.toString();		} catch (NumberFormatException nfe)		{			dateJSON = new StringBuffer();			String[] datentime = serverDateStamp.split(" ");			if (datentime != null && datentime.length == 3)			{				String[] dateparts = datentime[0].split("/");				try				{					String timestring = datentime[1];					String[] timeparts = timestring.split(":");					int hour = Integer.parseInt(timeparts[0]);					dateJSON.append("function(){var xdate= new Date();");					dateJSON.append("xdate.setFullYear(");					dateJSON.append(Integer.parseInt(dateparts[2]));					dateJSON.append(",");					dateJSON.append((Integer.parseInt(dateparts[1]) - 1));					dateJSON.append(",");					dateJSON.append(Integer.parseInt(dateparts[0]));					dateJSON.append(");");					dateJSON.append("xdate.setHours(");					dateJSON.append(hour);					dateJSON.append(");");					dateJSON.append("xdate.setMinutes(");					dateJSON.append(Integer.parseInt(timeparts[1]));					dateJSON.append(");");					dateJSON.append("xdate.setSeconds(");					dateJSON.append(Integer.parseInt(timeparts[2]));					dateJSON.append(");");					dateJSON.append("return xdate;}()");					return dateJSON.toString();				} catch (NumberFormatException nfex)				{					logger.cterror("CTBAS00008", Arrays.toString(dateFields));					return "NaD";				}			} else			{				logger.ctdebug("CTBAS00009", Arrays.toString(dateFields));				return "NaD";			}		} catch (ArrayIndexOutOfBoundsException ex)		{			return "NaD";		}	}	/**	 * Generates JSON string for a key Refer the class's documentation for more details about the JSON string generation	 * rules	 * 	 * @param aKey	 * @return string in JSON format	 */	private String generateJSONKey(Object aKey)	{		StringBuffer jsonString = new StringBuffer();		if (aKey != null)		{			jsonString.append(KEY_PREFIX);			jsonString.append(aKey.toString());			jsonString.append(KEY_SUFFIX);		} else			jsonString.append(JS_NULL_OBJECT);		return jsonString.toString();	}	/**	 * a helper method to create an Iterator given an object array	 * 	 * @param aCollection	 * @return a readonly iterator for the given object[], null if the input aCollection is null	 */	private Iterator getArrayIterator(final Object[] aCollection)	{		if (aCollection == null)			return null;		else		{			Iterator anIterator = new Iterator()			{				int currentIndex = 0;				public boolean hasNext()				{					return currentIndex < aCollection.length;				}				public Object next()				{					return aCollection[currentIndex++];				}				public void remove()				{					// empty implementation, as its only a read only iterator				}			};			return anIterator;		}	}	// prefix and suffix declaration as per JSON generation rules	private static final String HASHMAP_PREFIX = "{";	private static final String HASHMAP_SUFFIX = "}";	private static final String COLLECTION_PREFIX = "[";	private static final String COLLECTION_SUFFIX = "]";	private static final String HASHMAP_ELEMENT_SEPARATOR = ",";	private static final String COLLECTION_ELEMENT_SEPARATOR = ",";	private static final String HASHMAP_KEY_VALUE_SEPARATOR = ":";	private static final String KEY_PREFIX = "\"";	private static final String KEY_SUFFIX = "\"";	private static final String VALUE_PREFIX = "\"";	private static final String VALUE_SUFFIX = "\"";	private static final String JS_NULL_OBJECT = "null";	public static final String SYSTEM_DATE_FORMAT = "dd/MM/yyyy";	private static final SimpleDateFormat DEFAULT_DATE_FORMATTER = new SimpleDateFormat(SYSTEM_DATE_FORMAT);	private static boolean isHtmlEncodeNeed = true;	private List dateList = null;	private static final Logger logger = Logger.getLogger(HashMapToJSONConverter.class);}