/** * Copyright 2014. Intellect Design Arena Limited. All rights reserved.  *  * These materials are confidential and proprietary to Intellect Design Arena  * Limited and no part of these materials should be reproduced, published, transmitted * or distributed in any form or by any means, electronic, mechanical, photocopying,  * recording or otherwise, or stored in any information storage or retrieval system  * of any nature nor should the materials be disclosed to third parties or used in any  * other manner for which this is not authorized, without the prior express written  * authorization of Intellect Design Arena Limited. *   * @version 0.1 */Ext.namespace('iportal.widget');/* * @class This class's instance will be used for registering * MultiWidgetContainers. The class is intended to fetch the meta data of * multi-widget definition and then create an instance of the request specific * MultiWidget Container to be rendered on the screen */iportal.widget.MultiWidget = Ext.extend(Ext.util.Observable, {	mv : null,	layout : 'TAB',// default layout in case db doesnot return and layout value	childWidgets : [],	titleText : null,	height : iportal.jsutil.getMultiWidgetResizeHeight(),		selectedIndex : 0,	loadDefaultActions : false,	mergeWidgetActions : true,	indexPosition : 'left',	loadDefaultPositiveButtons : null,	loadDefaultNegativeButtons : null,		// apply the default properties and initiate the AJAX for loading meta data.	constructor : function (config){		// Copy configured listeners into *this* object so that the base class's		// constructor will add them.		iportal.widget.MultiWidget.superclass.constructor.call(this, config);		Ext.apply(this, config);		var event, mvc;		mvc = iportal.view.MultiViewConstants;		this.init();	},	setLayout : function (resValue){		this.layout = resValue.MULTI_WIDGET_MD.LAYOUT;	},		setChildWidgets : function (resValue){		var entldChildWgts = [];		var notEntldWgt = {};		var k = 0;				/**		 * Changes done, if the Multiwidget doesnt have child widgets, display the text.		 */		if (resValue.CHILD_WIDGETS.length == 0) {			var noChildWgt = {				WIDGET_DISPLAY_NM : "No Child Widget Configured",				WIDGET_ID : "NO_CHILD_WIDGET",				NO_OF_ROWS : "",				POSITION : "1"			};			entldChildWgts[0] = noChildWgt;			this.childWidgets = entldChildWgts;			this.layout = 'EMPTY';		}		else if (this.isHavEntiltedChilds(resValue)) {			if (resValue.MULTI_WIDGET_MD.LAYOUT == "INDEXED" || resValue.MULTI_WIDGET_MD.LAYOUT == "TAB"			|| resValue.MULTI_WIDGET_MD.LAYOUT == "SWITCH") {				for ( var i = 0; i < resValue.CHILD_WIDGETS.length; i++) {					if (resValue.CHILD_WIDGETS[i].IS_ENTITLED == 'Y') {						entldChildWgts[k] = resValue.CHILD_WIDGETS[i];						k++;					}				}				this.childWidgets = entldChildWgts;			}			else {				this.childWidgets = resValue.CHILD_WIDGETS;				iportal.workspace.metadata.setContainerChildWgtMD(this.childWidgets);			}		}		else {			notEntldWgt = {				WIDGET_DISPLAY_NM : "Not Entitled Widget",				WIDGET_ID : "NOT_ENTITLED_WIDGET",				NO_OF_ROWS : "",				POSITION : "1"			};			entldChildWgts[0] = notEntldWgt;			this.childWidgets = entldChildWgts;			this.layout = 'EMPTY';		}	},		setWidgetTitle : function (resValue){		// The title of the multi widget is always expected to be given in the		// common resource bundle		var rbCommon = CRB.getBundle(resValue.MULTI_WIDGET_MD.WIDGET_BUNDLE_KEY);		this.titleText = rbCommon[resValue.MULTI_WIDGET_MD.WGT_DISPLAY_NM] == null					? resValue.MULTI_WIDGET_MD.WGT_DISPLAY_NM : rbCommon[resValue.MULTI_WIDGET_MD.WGT_DISPLAY_NM];			/**		 * Adding the Multi Widget Title to its mv. This will be later claimed		 * by Portlet.js at the time of docking the widget in the catalog.		 */		if (this.mv)			{			this.mv.titleText = this.titleText;			this.mv.setTitle(this.titleText);			}			},	/**	 * Intended to updated the portlet to expand itself in case the first	 * child's INIT_COLLAPSED is 'N'	 */	setInitiCollapsedState : function (){		if (this.childWidgets != null && this.childWidgets.length > 0) {			var collapse = false;			if(!cbx.isEmpty(this.childWidgets[0]) && !cbx.isEmpty(this.childWidgets[0].INIT_COLLAPSED))					collapse  = this.childWidgets[0].INIT_COLLAPSED == 'Y' ? true : false;			var owner = this.mv.ownerCt;			if (owner != null && owner.showToolIcon) {				owner.showToolIcon({					"INIT_COLLAPSED" : collapse,					"COLLAPSE_IND" : collapse				});			}		}			},		/**	 * Method is intended to use the metadata received from the server and	 * update the associated properties of the Multi Widget and proceed to the	 * the creation of the MultiWidget Container as per the configured Layout	 */	setMetadata : function (md){		this.setLayout(md);		this.setWidgetTitle(md);		this.setChildWidgets(md);		this.setInitiCollapsedState(); 		this.initiateMultiWidgetContainer();	},		isHavEntiltedChilds : function (respValue){		var childWgts = respValue.CHILD_WIDGETS;		var isEntitled = false;		for(var i=0; i<childWgts.length; i++){			if(childWgts[i].IS_ENTITLED == 'Y'){				isEntitled = true;			}		}		return isEntitled;	},	/**	 * Create the mv and then checks if the meta data of the requested Multi	 * Widget is already cached in the IMM if yes, then use it and start the	 * initiation process otherwise make an ajax cal to the server to get the	 * md, cache it and then start the initiation process.	 */	init : function (){		this.createMv();		/*var cachedMd = IMM.getMultiWidgetMd(this.compId);		if (!Ext.isEmpty(cachedMd)) {			*//**			 * putting a delay as the mv creation is taking some time which			 * normally is taken care by the delay in ajax response.			 *//*			var task = new Ext.util.DelayedTask(this.setMetadata, this, [ cachedMd ]);			task.delay(100);		} else {*/			// code for making an AJAX to get all the widgets info		var cachedFlag=false;		var self=this;		canvas.metadata.getMetaData("MULTI_WIDGET",this.compId,function(metadatavalue){			if(!cbx.isEmpty(metadatavalue)){				try{					var cachedMetadata=Ext.decode(metadatavalue);					cachedFlag=true;					IMM.setMultiWidgetMd(cachedMetadata);					var task = new Ext.util.DelayedTask(self.setMetadata, self, [ cachedMetadata ]);					task.delay(300);					}					catch (e) {						LOGGER.error('Error while fetching Multi Widget Metadata cached data', e);						cachedFlag=false;					}			}			if(!cachedFlag){				// code for making an AJAX to get all the widgets info			var prms = {				INPUT_ACTION : "INIT_MULTI_HEADER_ACTION",				PAGE_CODE_TYPE : 'VDF_CODE',				PRODUCT_NAME : "CUSER",				INPUT_FUNCTION_CODE : "VSBLTY",				INPUT_SUB_PRODUCT : "CUSER",				__LISTVIEW_REQUEST : 'Y',				INPUT_PRODUCT : "CUSER",				INPUT_LANGUAGE_ID : iportal.preferences.getPrimaryLang(),				WIDGET_ID : this.compId			};			Ext.Ajax.request({				params : prms,				success : function (resp, options){					var respOb = Ext.decode(resp.responseText);					var md = respOb.response.value;					IMM.setMultiWidgetMd(md);					this.setMetadata(md);								setTimeout(function(){									try{									canvas.metadata.storeMetaData("MULTI_WIDGET",{id:self.compId,value:md,serverdatetime:respOb.HEADER_VALUE.TXN_PROCESS_DATE_TIME});									}									catch (e) {										LOGGER.error('Error while storing Multi Widget Metadata  cache', e);									}								},100);								setTimeout(function(){									try{									var responseValue=md;									if(responseValue.CHILD_WIDGETS && responseValue.CHILD_WIDGETS.length>0){										responseValue=responseValue.CHILD_WIDGETS;										for(var CW=0;CW<responseValue.length;CW++){											if(!cbx.isEmpty(responseValue[CW].WIDGET_ID)){																										cbx.core.app.model.getAppMetadata(responseValue[CW].WIDGET_ID, 1, cbx.emptyFn, self);												}										}									}									}									catch (e) {										LOGGER.error('Error while storing Multi Widget child Widget Metadata  cache', e);									}								},200);				},				scope : this			});			}		},this);				//}	},	/**	 * Intended to create the container under which the multiwidget<type> as	 * per the layout will be loaded. Another maint reason for creating this	 * wrapper is to follow the same object level hierarchy for creating a	 * singular widget. so that there is no extra code writted for layer that	 * lives on the abstraction of a Widget to be covered under a mv and then	 * mvh. For example, the protlet class doesn't care if it is loading a	 * singular or a multi widget under it. It uses the same code for interating	 * with both types of widgets. MAJORLY TO PROVIDE ABSTRACTION	 */	createMv : function (){		// Providing a Panel container parent for loading the multiwidget		// container in it		this.mv = new Ext.Panel({			isContainerWidgetMV : true,			itemId : this.compId,			height : this.height/* +25 */,			border : true,			/**			 * To be marked as true if the widget is directly getting loaded			 * under a portlet. This flag will be used to pass tool and title			 * ref to the portlet container header.			 */			isParentPortlet : false,			getToolsMenuItems : function (){				if (this.mwc && this.mwc.getToolsMenuItems) { 					return this.mwc.getToolsMenuItems();				}			},						activateChildWidget : function(widgetId){				this.mwc.activateChildCard(widgetId);			},						getSwitchViewIcon : function (){				if (this.mwc) {					if (this.mwc.getSwitchViewIcon) {						return this.mwc.getSwitchViewIcon();					}				}			},			getSwitchChartIcon : function (){				if (this.mwc) {					if (this.mwc.getSwitchChartIcon) {						return this.mwc.getSwitchChartIcon();					}				}			},						getPreferenceMenuItems : function (){				if (this.mwc && this.mwc.getPreferenceMenuItems) {					return this.mwc.getPreferenceMenuItems();				}			},						getTbarConf: function()			{				if(this.mwc && this.mwc.getTbarConf())					{					return this.mwc.getTbarConf();					}			},												/**			 * OnChange of currency ,Passing the currency value to			 * immediate parent			 * 			 * @param cmp			 * @param rec			 */			onCurrChange : function (currency){				if (this.mwc && this.mwc.onCurrChange) {					return this.mwc.onCurrChange(currency);				}			},			/**			 * Passing the currency to the immediate parent. This flag is			 * needed to be received by the portlet instance			 */			setCurrency : function (currency){				if (this.ownerCt && this.ownerCt.setCurrency) {					this.ownerCt.setCurrency(currency);				}			},						/**			 * Return the appropriate menu handler.			 */			handleToolAction : function (menuItem){				return this.mwc.handleToolAction(menuItem);			},						/**			 * Method to handle custom tool action			 * @ param 			 * customToolId			 */			handleCustomToolAction : function (customToolId,toolScope){				return this.mwc.handleCustomToolAction(customToolId,toolScope);				 			},			/* The method return the child menu of the parent tool.			 * @param menuId			 * */			getCustomToolsMenuItems: function(menuId)			{				return this.mwc.getCustomToolsMenuItems(menuId);				 			},						/**			*To get the tools map of the widget header.			*/			getToolsMap:function()			{				if (this.ownerCt && this.ownerCt.getToolsMap) {					return this.ownerCt.getToolsMap();				}				else					return {};			},					/**			 * Passing the show tool flag to the immediate parent. This flag is			 * needed to be received by the portlet instance			 */			showToolIcon : function (showFlag){				if (this.ownerCt && this.ownerCt.showToolIcon) {					this.ownerCt.showToolIcon(showFlag);				}			},			/**			 * Passing the show currency flag to the immediate parent. This flag			 * is needed to be received by the portlet instance			 */			showCurrencyInd : function (showFlag){				if (this.ownerCt && this.ownerCt.showCurrencyInd) {					this.ownerCt.showCurrencyInd(showFlag);				}			},					/**			 * Setting the title as per the current widget displayed on the			 * screen. This is applicable for multiwidget containers where only			 * one widget is displayed on the screen at a time.			 */			setTitle : function (title){				if (this.ownerCt && this.ownerCt.setTitle) {					this.ownerCt.setTitle(title);				}			}				});	},		/*	 * This method will be used for loading the meta data specific multi widget	 * container	 */	initiateMultiWidgetContainer : function (){		/*		 * In case the immediate parent is portlet, then send header and title		 * infomartion as per the metadata		 */		if (this.mv.isParentPortlet === true) {			if (this.mv.ownerCt != null && this.mv.ownerCt.setTitle) {								this.mv.ownerCt.setTitle(this.titleText);			}		}		iportal.workspace.metadata.getCurrentWorkspace().getWidgetContainer().appMVRegistry.registerWidget(this.compId,this.mv);				var mwc = null;		var conf = {			draggable : false,			height : this.height,						// additionConfig object can be sent by the developer as the			// initialize params for the widget. The container class is expected			// to push the additionalConfig object in all its child widget's mv.			additionalConfig : this.additionalConfig,						applyParentHeight : this.applyParentHeight,			childWidgets : this.childWidgets,			titleText : this.titleText,			parentWidget : this,			mymv : this.mv,			isContainerWidget : true,			itemId : this.compId,			commManager : cbx.CommManager,			appMVRegistry : iportal.workspace.metadata.getCurrentWorkspace().getWidgetContainer().appMVRegistry,			rbCommon : CRB.getFWBundle(),			errorbundle : CRB.getFWBundle(),			cls : 'multiapp',			border : true,			showErrWin : function (msg){				var message = msg || this.errorbundle['SYSERROR'];				var errWin = new iportal.Dialog({					dialogType : 'ERROR',									cls : 'portal_neg_btn',										message : message,					okHandler : function (){						errWin.close();					},					title : this.rbCommon['LBL_ERROR']				});				errWin.show();			}		};		if (this.layout == "TAB") {			mwc = new iportal.widget.MultiWidgetTab(conf);		} else if (this.layout == "CARD") {			mwc = new iportal.widget.MultiWidgetCard(conf);		} else if (this.layout == "EXPLORER") {			mwc = new iportal.widget.MultiWidgetExplorer(conf);				} else if (this.layout == "SWITCH") {			mwc = new iportal.widget.MultiWidgetSwitch(conf);						} else if (this.layout == "INDEXED") {			conf.selectedIndex = this.selectedIndex;			conf.mergeWidgetActions = this.mergeWidgetActions;			conf.loadDefaultActions = this.loadDefaultActions;			/**			 * Flipping the index panel as per the RTL direction.			 */			if (iportal.preferences.isLangDirectionRTL()) {				if (this.indexPosition == 'right') {					this.indexPosition = 'left';				} else {					this.indexPosition = 'right';				}			}			conf.indexPosition = this.indexPosition;			if (this.loadDefaultPositiveButtons) {				conf.loadDefaultPositiveButtons = this.loadDefaultPositiveButtons;			}			if (this.loadDefaultNegativeButtons) {				conf.loadDefaultNegativeButtons = this.loadDefaultNegativeButtons;			}			mwc = new iportal.widget.IndexedMultiWidget(conf);		}				else if (this.layout == "TWO-COLUMN") {			mwc = new iportal.widget.MultiWidgetTwoColumn(conf)		} else if (this.layout == "STACK") {			mwc = new iportal.widget.MultiWidgetStack(conf)		}			else if(this.layout == 'EMPTY'){						var rb = CRB.getFWBundle();					/**			 * Changes done, if the Multiwidget doesnt have child widgets, display the text.			 */			if (this.childWidgets[0].WIDGET_ID == "NO_CHILD_WIDGET") {								mwc = new Ext.Panel({					html : rb['NO_CHILD_WIDGETS']				});			} 			else if (this.childWidgets[0].WIDGET_ID == "NOT_ENTITLED_WIDGET") {								mwc = new Ext.Panel({					html : rb['NOT_ENTITLED_WIDGETS']				});			}					}						if (mwc != null) {			this.mv.mwc = mwc;			this.mv.add(mwc)			this.mv.doLayout();		}	},	setParentHeight : function (height){		this.height = height		this.mv.height = height;		this.applyParentHeight = true;		this.mv.applyParentHeight = true		/*		 * if(!Ext.isEmpty(this.mv.mwc)){ this.mv.mwc.setParentHeight(height); }		 */	}});