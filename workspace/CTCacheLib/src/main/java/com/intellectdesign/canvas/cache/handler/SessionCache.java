/** * Copyright 2014. Intellect Design Arena Limited. All rights reserved.  *  * These materials are confidential and proprietary to Intellect Design Arena  * Limited and no part of these materials should be reproduced, published, transmitted * or distributed in any form or by any means, electronic, mechanical, photocopying,  * recording or otherwise, or stored in any information storage or retrieval system  * of any nature nor should the materials be disclosed to third parties or used in any  * other manner for which this is not authorized, without the prior express written  * authorization of Intellect Design Arena Limited. *  */package com.intellectdesign.canvas.cache.handler;import java.util.Date;import java.util.HashMap;import java.util.List;import javax.servlet.http.HttpSession;/** * This represents a session level cache. This internally maintains an object in the session having the list of cache * keys created for this session. *  * @version 1.0 */public final class SessionCache extends Cache{	/**	 * The default constructor. Sets the scope of the cache by default.	 */	public SessionCache()	{		setScope(CacheConstants.SCOPE_SESSION);	}	/**	 * (non-Javadoc) ref too Session CacheData Available	 * 	 * @param cachekey,session	 * @return session	 * @see com.intellectdesign.cib.cache.Cache#isCacheDataAvailable(java.lang.String, javax.servlet.http.HttpSession)	 */	@Override	protected boolean isCacheDataAvailable(String cacheKey, HttpSession session)	{		return null != session.getAttribute(cacheKey);	}	/**	 * ref to Does the actual get operation. Default implementation is to get it from teh Cache mananger's internal	 * store	 * 	 * @param cacheKey The cache key provided by caller	 * @param session The session object	 * @return The data for the cache	 */	protected List getDataImpl(String cacheKey, HttpSession session)	{		// if the session cache data is to be maintained in the session then		return getDataFromSession(session);		// else it is maintained by the cache manager in which case just call the super		// else return super.getData(session);	}	/**	 * ref to Prepares the params for passing to the Cache handler. Here we load the session info from the session and	 * pass it on to the handler	 * 	 * @param session The session object	 * @return HashMap The parameters to be passed to the handler proxy	 */	protected HashMap getHandlerParams(HttpSession session)	{		HashMap params = new HashMap();		if (session != null)		{			Object sessInfo = session.getAttribute("sessionInfo");			params.put(CacheConstants.OBJECT_SESSIONINFO, sessInfo);		}		return params;	}	/**	 * This method gets the data corresponding to this cache for the given session. This gets the data from the session	 * itself .	 * 	 * @param session the session object	 * @return ArrayList The cached data.	 */	protected List getDataFromSession(HttpSession session)	{		List retVal = null;		String cacheKey = getInternalCacheKey(session);		if (session.getAttribute(cacheKey) == null)		{			initCache(session);		}		retVal = (List) session.getAttribute(cacheKey);		return retVal;	}	/**	 * this methos is used to Override the base class implementation to register session listeners.	 * 	 * @param session The session object.	 */	protected void initCache(HttpSession session)	{		// if sessioncache store is to be maintained in the session		initSessionCacheUsingSession(session);	}	/**	 * This method is called when the cached data is to be destroyed. This just removes the cached object from the	 * Session	 */	@Override	protected void destroyCache(HttpSession session)	{		String cacheKey = getInternalCacheKey(session);		if (isCacheDataAvailable(cacheKey, session))		{			session.removeAttribute(cacheKey);		}	}	/**	 * metod is called Override the base class implementation to load the session cache information into the session.	 * This is done to take care of session replication in a clustered mode for session level information	 * 	 * @param session The session object.	 */	protected void initSessionCacheUsingSession(HttpSession session)	{		List data = null;		String cacheKey = getInternalCacheKey(session);		// Retrieve the data from the handler		data = getHandler().initializeCache(getHandlerParams(session));		// Put the data into the cache. This will replace any data already present in the cache.		session.setAttribute(cacheKey, data);		// Set the time of initialization for the cache.		setInitializedTime(new Date());	}	/**	 * ref to Initialize the session cache using the cache manager	 * 	 * @param session The session object.	 */	protected void initSessionCacheUsingCacheManager(HttpSession session)	{		if (session != null)		{			SessionCacheStore store = (SessionCacheStore) session.getAttribute(CacheConstants.SESSION_CACHE_STORE_KEY);			if (store == null)			{				store = new SessionCacheStore();				session.setAttribute(CacheConstants.SESSION_CACHE_STORE_KEY, store);			}			// Add the cache key to the cache store.			store.getCacheKeyList().add(getInternalCacheKey(session));		}		// Call the base class as it knows how to proceed with the initialization.		super.initCache(session);	}	/**	 * ref to Implementation of abstract method of base class. Always returns false to indicate that pre load is not	 * supported for session cache	 * 	 * @return boolean Always false as preload is not supported	 */	protected boolean isPreLoadSupported()	{		return false;	}	/**	 * Implementation of abstract method of base class. Always returns false to indicate that expiry is not supported	 * for session cache	 * 	 * @return boolean Always false as expiry is supported	 */	protected boolean isExpirySupported()	{		return false;	}	/**	 * Gets the internal cache key corresponding to this cache.	 * 	 * @param session The session object. This is ignored	 * @return String the key to be used for caching the data corresponding to this cache.	 */	protected String getInternalCacheKey(HttpSession session)	{		return getId() + "-" + session.getId();	}}