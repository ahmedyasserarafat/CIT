/** * Copyright 2014. Intellect Design Arena Limited. All rights reserved.  *  * These materials are confidential and proprietary to Intellect Design Arena  * Limited and no part of these materials should be reproduced, published, transmitted * or distributed in any form or by any means, electronic, mechanical, photocopying,  * recording or otherwise, or stored in any information storage or retrieval system  * of any nature nor should the materials be disclosed to third parties or used in any  * other manner for which this is not authorized, without the prior express written  * authorization of Intellect Design Arena Limited. *  */package com.intellectdesign.canvas.alert.smtp;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import com.intellectdesign.canvas.alert.handler.AlertConstants;import com.intellectdesign.canvas.alert.handler.AlertDetail;import com.intellectdesign.canvas.alert.handler.AlertHandlerException;import com.intellectdesign.canvas.alert.handler.IMessage;import com.intellectdesign.canvas.alert.handler.IRecipient;import com.intellectdesign.canvas.alert.handler.Message;import com.intellectdesign.canvas.cache.handler.CacheManager;import com.intellectdesign.canvas.config.ConfigurationManager;import com.intellectdesign.canvas.config.SystemPreferenceDescriptor;import com.intellectdesign.canvas.event.Event;import com.intellectdesign.canvas.logger.Logger;import com.intellectdesign.canvas.properties.reader.PropertyReader;/** * This class provides generic implementation for IChannelHandler. This is an abstract class to encapsulate and abstract * the process for sending the alerts and notification *   * @version 1.0 */public abstract class GenericChannelHandler implements IChannelHandler, Comparable{	/**	 * This method provides the alert data to send messages to through the class that extends the 	 * the this GenericChannelHandler class	 * 	 * @param event - Event object that contents the event data	 * @param alertDetail - AlertDetail object that contains the alert data	 * @param hmMsgData - HashMap of the alert message data such as Receipients, Detail and Short Messages\	 * 	 * @throws AlertHandlerException	 */	public void sendMessage(Event event, AlertDetail alertDetail, HashMap hmMsgData) throws AlertHandlerException	{		logger.ctinfo("CTALT00463");		// The unformatted message to be stored in database		HashMap hmAlertData = (HashMap) hmMsgData.get(AlertConstants.ALERT_DATA_MAP);		String sLocale = (String) hmMsgData.get(AlertConstants.LOCALE_KEY);		IMessage message = getMesage(hmAlertData, alertDetail, sLocale);		// List of user ids for whom the message is to be sent is expected to be in the hashMap with the key		// AlertConstants.RECIPIENTS_KEY.		ArrayList listUserIDs = (ArrayList) hmMsgData.get(AlertConstants.RECIPIENTS_KEY);		// Arraylist of type IRecipients that contains details of the recipient (user id + GCIF)		ArrayList listRecipients = null;		// get the recipients info from db using the user ids.		if (listUserIDs != null && !listUserIDs.isEmpty())		{			/**			 * Provided the option to fetch the receipant details from the data map instead of db. This implementation			 * for Custom Smtp Channel Handler.			 */			try			{				listRecipients = getRecipientsInfoFromDB(listUserIDs);			} catch (UnsupportedOperationException uoe)			{				listRecipients = getRecipientsInfoFromDB(listUserIDs, hmMsgData);			}		}		// Sender key is expected to be in the hashmap with the key AlertConstants.SENDER_KEY.		String sSender = (String) hmMsgData.get(AlertConstants.SENDER_KEY);		// If such a key is not present in the hashmap, then the sender is defaulted to AlertConstants.SYSTEM_SENDER		if (sSender == null)			sSender = AlertConstants.SYSTEM_SENDER;		logger.ctdebug("CTALT00464", listRecipients);		logger.ctinfo("CTALT00465");		if (listRecipients == null)		{			// Case - No recipients defined for the alert			// throw new			// AlertHandlerException("List of recipients null.","List of recipients null. Not able to process the alert");			logger.cterror("CTALT00466");		} else		{			// Single recipient case			if (listRecipients.size() == 1)				send(message, (IRecipient) listRecipients.get(0), sSender, alertDetail.getAlertId());			// Multiple recipient case			else if (listRecipients.size() > 1)				send(message, listRecipients, sSender, alertDetail.getAlertId());		}	}		/**	 * This is an abstract method to send message to the Subscribed Recipients through the Channels subscribed	 * 	 * @param event - Event object that contains the Event Data	 * @param alertDetails - AlertDetail object that contains the Alert Data	 * @param DataMap - Hashmap of Alert Message that contains the Receipients	 * 	 * @throws AlertHandlerException	 * 	 * @see com.intellectdesign.canvas.alert.smtp.IChannelHandler#postMessage(com.intellectdesign.canvas.event.Event, com.intellectdesign.canvas.alert.handler.AlertDetail, java.util.HashMap)	 */	public abstract void postMessage(Event event, AlertDetail alertDetails, HashMap DataMap)			throws AlertHandlerException; // CHCR	/**	 * This is a helper method that a channel should implement if in the input data map it expects the application to	 * set User Nos instead of channel specific recipients. All implementing methods are expected to return a list of	 * IRecipient objects.	 * 	 * @param listUserIDs  - ArrayList object that contains the list of User Nos	 * @return RecipientsInfo - ArrayList object that containst the details of the User No	 * 	 * @throws AlertHandlerException	 */	protected abstract ArrayList getRecipientsInfoFromDB(ArrayList listUserIDs) throws AlertHandlerException;	/**	 * This is a helper method that a channel should implement if in the input data map it expects the application to	 * set user ids instead of channel specific recipients. All implementing methods are expected to return a list of	 * Recipient details. 	 * 	 * @param listUserIDs - Arraylist object that contains the list of user No	 * @return ArrayList - ArrayList object that contains the User Details for the given User Nos and Alert Message Data	 * 	 * @throws AlertHandlerException	 */	protected ArrayList getRecipientsInfoFromDB(ArrayList listUserIDs, HashMap hmMsgData) throws AlertHandlerException	{		return null;	}	/**	 * The core method which encapsulates the channel specific logic for sending messages using appropriate	 * methodologies for respective technologies. This mehtod should be overidden to dispatch the alert or notification to the	 * appropriate channel.	 * 	 * @param msg - message object that contains the message as understood by the Channel.	 * @param recipient - Recipient object that contains the User Nos who would recieve the message. 	 * @param sSender - String value of the sender information as relevant for the Channel.	 * @param sAlertId - String value of the Alert id 	 * 	 * @throws AlertHandlerException	 */	protected abstract void send(IMessage msg, IRecipient recipient, String sSender, String sAlertId)			throws AlertHandlerException;	/**	 * The core method which encapsulates the channel specific logic for sending messages using appropriate	 * methodologies for respective technologies. This is an overridden method only to encapsulate sending the message	 * to multiple recipients. This method should be overidden to dispatch the alert or notification to the appropriate channel.	 * This method is intended to be used for sending bulk messages.	 * 	 * @param msg - Message object as understood by the Channel.	 * @param listRecipients - ArrayList object that contains list of recipients who would recieve the message. 	 * @param sSender - String value of the Sender Detail as relevant for the Channel.	 * @param sAlertId - String value of the Alert id	 * 	 * @throws AlertHandlerException	 */	protected abstract void send(IMessage msg, ArrayList listRecipients, String sSender, String sAlertId)			throws AlertHandlerException;	/**	 * The Method creates formatted short and detail message as specified in the application alert message template. 	 * If the data keys associated with the given alert is null, an unformatted message will be formed. 	 * Otherwise, a formatted message is formed. An unformatted message is a string which is not an	 * actual message but contains the data required to form the message. The data will be in the form of key value pairs	 * each seperated by a delimiter <code>key1</code>=<code>value1</code>$$<code>key2</code>=<code>value2</code>$$...... 	 * The assignment operator '=' and the delimiter key '$$' are configured in the property file <code>canvas_alert_properties.properties</code>	 * 	 * @param hmMsgData - Hashmap object that contains the message data	 * @param alertDetail - Hashmap object that contains the alert data	 * @param sLocale - String value of the user preferred Locale Id 	 * @return IMessage - Message object that contains the formated message	 * @throws AlertHandlerException	 */	private IMessage getMesage(HashMap hmMsgData, AlertDetail alertDetail, String sLocale) throws AlertHandlerException	{		logger.ctinfo("CTALT00467");		logger.ctdebug("CTALT00468", hmMsgData, sLocale);		// This String buffer will contain the list of key values pairs of the data that are needed to form the alert		StringBuffer sbData = null;		String sUnformattedMessage = null;		Message message = new Message();		message.setAlertId(alertDetail.getAlertId());		ArrayList alistDataKeys = null;		HashMap hmDataKeys = null;		List listDataKeys = null;		// This is to ensure that no null pointer exception is thrown if the map is empty		if (hmMsgData == null)			hmMsgData = new HashMap();		// Get the alert data keys for the given alert id from the database		List listCachedDataKeys = CacheManager.getFWInstance().getDataFromCache(null, AlertConstants.ALERT_DATA_KEYS);		if (listCachedDataKeys != null && listCachedDataKeys.size() > 0)		{			HashMap alertDataKeyMap = (HashMap) listCachedDataKeys.get(0);			logger.ctdebug("CTALT00469", alertDataKeyMap);			listDataKeys = (List) alertDataKeyMap.get(alertDetail.getAlertId());		}		// If there are no data keys for an alert, listDataKeys could be null.		// No need to throw an excpetion as the message could be a static message in that case		if (listDataKeys != null && !listDataKeys.isEmpty())		{			// Form ArrayList of DataKeys			alistDataKeys = new ArrayList();			for (int i = 0; i < listDataKeys.size(); i++)			{				hmDataKeys = (HashMap) listDataKeys.get(i);				alistDataKeys.add(hmDataKeys.get(AlertConstants.DATA_KEY));			}		}		logger.ctdebug("CTALT00962", alistDataKeys);		if (alistDataKeys != null && !alistDataKeys.isEmpty())		{			// This condition is for unformatted Message. In an unformatted message, the detailed message contains the			// key value pairs need to form the actual message			sbData = new StringBuffer();			for (int i = 0; i < alistDataKeys.size(); i++)			{				sbData.append(alistDataKeys.get(i));				sbData.append(prptReader.retrieveProperty("ASSIGNMENT_KEY"));				if (hmMsgData.get(alistDataKeys.get(i)) != null)					sbData.append(hmMsgData.get(alistDataKeys.get(i)));				else					sbData.append("");				if (i != (alistDataKeys.size() - 1))					sbData.append(prptReader.retrieveProperty("DELIMITER_KEY"));			}			if (sbData != null)			{				sUnformattedMessage = sbData.toString();				message.setDetailedMessage(sUnformattedMessage);			}			message.setFormatted(false);		} else		{			// This is for a formatted message. The short and detailed description template has the actual message to be			// sent			if (sLocale == null || sLocale.isEmpty())			{				sLocale = "en_US";			}			ConfigurationManager confMngr = ConfigurationManager.getInstance();			SystemPreferenceDescriptor sysDscr = confMngr.getSystemPrefDescriptor();			PropertyReader msgPrptReader = new PropertyReader(sysDscr.getAlertTemplateFile() + "_" + sLocale);			logger.ctdebug("CTALT00117", alertDetail.getAlertId(), sChannelName);			// The key to get the short message template is formed using the Alert Id, Channel Id and the constant			// AlertConstants.SHORT_DESCRIPTION_TEMPLATE.			String sShortMsgTemplateKey = new StringBuffer(alertDetail.getAlertId()).append(sChannelName)					.append(AlertConstants.SHORT_DESCRIPTION_TEMPLATE).toString();			// The key to get the detailed message template is formed using the Alert Id, Channel Id and the constant			// AlertConstants.DETAILED_DESCRIPTION_TEMPLATE.			String sDetailedMsgTemplateKey = new StringBuffer(alertDetail.getAlertId()).append(sChannelName)					.append(AlertConstants.DETAILED_DESCRIPTION_TEMPLATE).toString();			// Get the short message			String sShortMessage = msgPrptReader.retrieveProperty(sShortMsgTemplateKey);			// Get the detailed Message			String sDetailedMessage = msgPrptReader.retrieveProperty(sDetailedMsgTemplateKey);			message.setShortMessage(sShortMessage);			message.setDetailedMessage(sDetailedMessage);			message.setFormatted(true);		}		// Store the enriched data values into the message always.		message.setEnrichBankName((String) hmMsgData.get(AlertConstants.KEY_ENRICH_BANK_NAME));		message.setEnrichBranchName((String) hmMsgData.get(AlertConstants.KEY_ENRICH_BRANCH_NAME));		message.setEnrichCcy((String) hmMsgData.get(AlertConstants.KEY_ENRICH_CCY));		message.setEnrichCountryName((String) hmMsgData.get(AlertConstants.KEY_ENRICH_COUNTRY_NAME));		message.setEnrichSubProduct((String) hmMsgData.get(AlertConstants.KEY_ENRICH_SUBPROD_DESC));		logger.ctinfo("CTALT00196");		return message;	}	/**	 * This method sets the ChannelId	 * 	 * @param sChannelId  - String value of the channel id 	 */	public void setChannelId(String sChannelId)	{		this.sChannelId = sChannelId;	}	/**	 * This method gets the ChannelId	 * 	 * @return sChannelId - String value of the Channel ID	 */	public String getChannelId()	{		return this.sChannelId;	}	/**	 * This method sets the name of the Alert Message Channel 	 * 	 * @param sChannelName - String value of the Channel name 	 * 	 */	public void setChannelName(String sChannelName)	{		this.sChannelName = sChannelName;	}	/**	 * This method gets the name of the Alert Message Channel	 * 	 * @return sChannelName - String value of the Channel name	 */	public String getChannelName()	{		return this.sChannelName;	}	/**	 * This is an overriden method. 	 * This method returns the channel Id as hashCode value.  	 * 	 * @return ChannelId - HashCode value of the current Channel Handler	 *  	 */	public int hashCode()	{		return Integer.parseInt(this.getChannelId());	}	/**	 * This is a overriden method. This method compares the current ChannelId with the Channerl Id of the Handler Object passed as parameter	 * 	 * @param aChannelHandler - ChannelHandler object that contains the ChannelId	 * @return ComparedValue - <br> 0 if the both the ChannelIds are same; 	 * <br>a value less than 0 if this channelId is lexicographically less than the string argument;	 * <br>a value less than 0 if this channelId is lexicographically greater than the string argument; 	 */	public int compareTo(Object aChannelHandler)	{		return this.getChannelId().compareTo(((GenericChannelHandler) aChannelHandler).getChannelId());	}	/**	 * This is a overriden method. This method checks whether the current Channel Id and 	 * the Channel Id of the Channel Handler object are same or not.	 * 	 * @param aChannelHandler - ChannelHandler object that contains the ChannelId	 * @return true if channel Ids are same otherwise false 	 */	public boolean equals(Object aChannelHandler)	{		logger.ctdebug("CTALT00121");		return this.getChannelId().equals(((GenericChannelHandler) aChannelHandler).getChannelId());	}	private String sChannelId = null;	private String sChannelName = null;	private static final Logger logger = Logger.getLogger(GenericChannelHandler.class);	private static PropertyReader prptReader = AlertConstants.ALERT_PROPERTIES;}